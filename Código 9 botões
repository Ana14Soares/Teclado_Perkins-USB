#include "USB.h"
#include "USBHIDKeyboard.h"

// Inicializa o objeto teclado
USBHIDKeyboard Keyboard;

// Definição dos pinos Braille (Pontos 1 a 6)
const int pino_b1 = 16;  // Ponto 1
const int pino_b2 = 17;  // Ponto 2
const int pino_b3 = 18;  // Ponto 3
const int pino_b4 = 15;  // Ponto 4
const int pino_b5 = 7;   // Ponto 5
const int pino_b6 = 6;   // Ponto 6

// Definição dos pinos das Teclas de Função
const int pEnter = 41;   // Pino do botão Enter
const int pEspaco = 42;  // Pino do botão Espaço (além do ponto Braille)
const int pDelete = 2;   // Pino do botão Delete/Backspace

// Array para facilitar o acesso aos pinos Braille
const int PINOS_BRAILLE[6] = {pino_b1, pino_b2, pino_b3, pino_b4, pino_b5, pino_b6};
const int PINOS_FUNCAO[3] = {pEnter, pEspaco, pDelete};


// Variáveis de controle do buffer
bool bufferAtivo = false;
unsigned long tempoInicio = 0;
const unsigned long TEMPO_ESPERA = 300; // Tempo em ms para considerar a combinação finalizada
const unsigned long DEBOUNCE_DELAY = 50; 

int buffer[6] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH};
int leituraAnterior[6] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH};

// Protótipos das funções
void limparBuffer();
void aguardarSoltarBotoes();
void processarBuffer();

// ===== SETUP =====

void setup() {
  // Configuração inicial da comunicação USB (HID)
  Keyboard.begin();
  USB.begin();
  
  delay(100);
  
  // Configura pull-up nos pinos Braille
  for (int i = 0; i < 6; i++) {
    pinMode(PINOS_BRAILLE[i], INPUT_PULLUP);
  }

  // Configura pull-up nos pinos de Função
  for (int i = 0; i < 3; i++) {
    pinMode(PINOS_FUNCAO[i], INPUT_PULLUP);
  }
}

void loop() {
  // 1. Verifica Botões de Função (Enter, Espaço, Delete)
  
  // O uso do 'return' garante que a leitura Braille não ocorra enquanto um botão de função é pressionado.

  // Verifica botão Delete (Backspace)
  if (digitalRead(pDelete) == LOW) {
    Keyboard.write(KEY_BACKSPACE); // Envia Backspace USB
    // Espera o botão ser solto e aplica debounce
    while (digitalRead(pDelete) == LOW) { delay(10); }
    delay(DEBOUNCE_DELAY);
    return;
  }

  // Verifica botão Enter (FUNÇÃO RESTAURADA)
  if (digitalRead(pEnter) == LOW) {
    // Usando press/release para simular o Enter de forma mais robusta
    Keyboard.press(KEY_RETURN); 
    delay(5); // Pequeno atraso para o sistema reconhecer o pressionamento
    Keyboard.release(KEY_RETURN);
    
    // Espera o botão ser solto e aplica debounce
    while (digitalRead(pEnter) == LOW) { delay(10); }
    delay(DEBOUNCE_DELAY);
    return;
  }

  // Verifica botão Espaço (além da combinação braille de espaço)
  if (digitalRead(pEspaco) == LOW) {
    Keyboard.write(' '); // Envia espaço USB
    // Espera o botão ser solto e aplica debounce
    while (digitalRead(pEspaco) == LOW) { delay(10); }
    delay(DEBOUNCE_DELAY);
    return;
  }

  // 2. Lógica do Teclado Braille (Pontos 1 a 6)
  
  // Leitura atual dos botões Braille
  int leituraAtual[6];
  for (int i = 0; i < 6; i++) {
    leituraAtual[i] = digitalRead(PINOS_BRAILLE[i]);
  }

  bool algumPressionado = false;
  bool novasTeclasDetectadas = false;
  
  for (int i = 0; i < 6; i++) {
    if (leituraAtual[i] == LOW) {
      algumPressionado = true;
      // Detecta nova tecla pressionada (transição de HIGH para LOW)
      if (leituraAnterior[i] == HIGH) {
        novasTeclasDetectadas = true;
      }
    }
  }

  // Inicia o buffer quando a primeira tecla for pressionada
  if (algumPressionado && !bufferAtivo) {
    bufferAtivo = true;
    tempoInicio = millis();
    limparBuffer();
  }

  // Armazena estados e reinicia o timer
  if (bufferAtivo) {
    for (int i = 0; i < 6; i++) {
      if (leituraAtual[i] == LOW) {
        buffer[i] = LOW;
      }
    }

    // Reinicia o tempo de espera se uma nova tecla for detectada
    if (novasTeclasDetectadas) {
      tempoInicio = millis();
    }

    // Verifica se o tempo de espera terminou (combinação finalizada)
    if (millis() - tempoInicio >= TEMPO_ESPERA) {
      processarBuffer();
      aguardarSoltarBotoes(); // Espera soltar os botões Braille
      bufferAtivo = false;
      limparBuffer();
    }
  }

  // Atualiza leitura anterior para o próximo loop
  for (int i = 0; i < 6; i++) {
    leituraAnterior[i] = leituraAtual[i];
  }

  delay(10);
}

// ===== FUNÇÕES AUXILIARES =====

// Função para limpar o buffer (reseta para HIGH/Solto)
void limparBuffer() {
  for (int i = 0; i < 6; i++) {
    buffer[i] = HIGH;
  }
}

// Função para aguardar soltar todos os botões Braille
void aguardarSoltarBotoes() {
  // Loop para garantir que todos os 6 botões Braille sejam soltos
  for (int i = 0; i < 6; i++) {
    while (digitalRead(PINOS_BRAILLE[i]) == LOW) {
      delay(10);
      i = -1; // Reinicia o loop para re-checar todos
    }
  }
  delay(DEBOUNCE_DELAY); 
}

// Função para processar o buffer e identificar a letra
void processarBuffer() {
  // Os pontos Braille: true = Pressionado (LOW), false = Solto (HIGH)
  bool b1 = (buffer[0] == LOW);
  bool b2 = (buffer[1] == LOW);
  bool b3 = (buffer[2] == LOW);
  bool b4 = (buffer[3] == LOW);
  bool b5 = (buffer[4] == LOW);
  bool b6 = (buffer[5] == LOW);

  char letra = '\0'; // Inicializa com caractere nulo

  // --- Mapeamento Braille para Caractere ---
  
  // A = 100000
  if (b1 && !b2 && !b3 && !b4 && !b5 && !b6) { letra = 'a'; } 
  // B = 110000
  else if (b1 && b2 && !b3 && !b4 && !b5 && !b6) { letra = 'b'; } 
  // C = 100100
  else if (b1 && !b2 && !b3 && b4 && !b5 && !b6) { letra = 'c'; } 
  // D = 100110
  else if (b1 && !b2 && !b3 && b4 && b5 && !b6) { letra = 'd'; } 
  // E = 100010
  else if (b1 && !b2 && !b3 && !b4 && b5 && !b6) { letra = 'e'; } 
  // F = 110100
  else if (b1 && b2 && !b3 && b4 && !b5 && !b6) { letra = 'f'; } 
  // G = 110110
  else if (b1 && b2 && !b3 && b4 && b5 && !b6) { letra = 'g'; } 
  // H = 110010
  else if (b1 && b2 && !b3 && !b4 && b5 && !b6) { letra = 'h'; } 
  // I = 010100
  else if (!b1 && b2 && !b3 && b4 && !b5 && !b6) { letra = 'i'; } 
  // J = 010110
  else if (!b1 && b2 && !b3 && b4 && b5 && !b6) { letra = 'j'; } 
  // K = 101000
  else if (b1 && !b2 && b3 && !b4 && !b5 && !b6) { letra = 'k'; } 
  // L = 111000
  else if (b1 && b2 && b3 && !b4 && !b5 && !b6) { letra = 'l'; } 
  // M = 101100
  else if (b1 && !b2 && b3 && b4 && !b5 && !b6) { letra = 'm'; } 
  // N = 101110
  else if (b1 && !b2 && b3 && b4 && b5 && !b6) { letra = 'n'; } 
  // O = 101010
  else if (b1 && !b2 && b3 && !b4 && b5 && !b6) { letra = 'o'; } 
  // P = 111100
  else if (b1 && b2 && b3 && b4 && !b5 && !b6) { letra = 'p'; } 
  // Q = 111110
  else if (b1 && b2 && b3 && b4 && b5 && !b6) { letra = 'q'; } 
  // R = 111010
  else if (b1 && b2 && b3 && !b4 && b5 && !b6) { letra = 'r'; } 
  // S = 011100
  else if (!b1 && b2 && b3 && b4 && !b5 && !b6) { letra = 's'; } 
  // T = 011110
  else if (!b1 && b2 && b3 && b4 && b5 && !b6) { letra = 't'; } 
  // U = 101001
  else if (b1 && !b2 && b3 && !b4 && !b5 && b6) { letra = 'u'; } 
  // V = 111001
  else if (b1 && b2 && b3 && !b4 && !b5 && b6) { letra = 'v'; } 
  // W = 010111
  else if (!b1 && b2 && !b3 && b4 && b5 && b6) { letra = 'w'; } 
  // X = 101101
  else if (b1 && !b2 && b3 && b4 && !b5 && b6) { letra = 'x'; } 
  // Y = 101111
  else if (b1 && !b2 && b3 && b4 && b5 && b6) { letra = 'y'; } 
  // Z = 101011
  else if (b1 && !b2 && b3 && !b4 && b5 && b6) { letra = 'z'; } 
  // ESPAÇO (combinação Braille 000000)
  else if (!b1 && !b2 && !b3 && !b4 && !b5 && !b6) { letra = ' '; } 

  // --- Ação de Digitar (Teclado HID) ---
  if (letra != '\0') {
    Keyboard.write(letra); // Envia para o computador
  }
}
